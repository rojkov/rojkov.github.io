<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Yet another personal blog."><meta name="author" content="Dmitry Rozhkov"><title>Idempotent info | Idempotent info</title><link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css"><link rel="canonical" href="http://idempotent.info/index.html"><!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]--><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"></head><body>
<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://idempotent.info/">Idempotent info</a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
        <ul class="nav navbar-nav"><li><a href="stories/about.html">About</a>
                </li><li><a href="archive.html">Archives</a>
                </li><li><a href="categories/index.html">Tags</a>
                </li><li><a href="rss.xml">RSS</a>

        </li></ul><ul class="nav navbar-nav navbar-right"></ul></div><!-- /.navbar-collapse -->
</nav><!-- End of Menubar --><div class="container">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
        <article class="postbox h-entry post-text"><h1 class="p-name"><a href="posts/how-to-configure-devel-environment-to-work-on-gecko-for-sailfishos.html" class="u-url">How to configure devel environment to work on Gecko for SailfishOS</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2014-03-20T15:44:36+00:00">2014-03-20 15:44</time></small></h1>
        <hr><div class="e-content">
        <div><p>It turned out that newcomers have difficulties with setting up their development
environment to work on Gecko integration with Nemo, SailfishOS or any other
Mer-based Linux. Hence this post.</p>
<!-- TEASER_END -->
<div class="section" id="configure-development-environment">
<h2>Configure development environment</h2>
<p>Gecko engine development for embedded devices is quite resource consuming.
If you want to try it you'd better have a mighty computer running Linux and
avoid virtualization. It's better not to use the standard SailfishOS SDK,
but to resort to Mer chroot-based SDK.</p>
<p>First of all you'll need to install Mer platform SDK and enter into it. Look at
<a class="reference external" href="https://wiki.merproject.org/wiki/Platform_SDK">this wiki page</a> for details and
follow the instructions till the part "Basic tasks".</p>
<p>Then you'll need to create and install a rootfs. More detailed instructions
can be found <a class="reference external" href="https://wiki.merproject.org/wiki/Platform_SDK_and_SB2">here</a>,
but below is an extarct from there:</p>
<pre class="literal-block">
MerSDK$ sudo mkdir -p /parentroot/srv/mer/targets
MerSDK$ cd /tmp
</pre>
<p>Now in the current directory (which is /tmp) create a file <cite>mer-target-armv7hl.ks</cite>
with the following content:</p>
<pre class="literal-block">
# -*-mic2-options-*- --arch=armv7hl -*-mic2-options-*-

lang en_US.UTF-8
keyboard us
timezone --utc UTC
part / --size 500 --ondisk sda --fstype=ext4
rootpw rootme

user --name mer  --groups audio,video --password rootme

repo --name=sailfish --baseurl=http://releases.jolla.com/releases/latest/jolla/armv7hl --save --debuginfo

%packages
glibc-devel
mesa-llvmpipe-libEGL-devel
mesa-llvmpipe-libGLESv2-devel
shadow-utils
rpm-build
meego-rpm-config
zypper
%end

%post
## rpm-rebuilddb.post from mer-kickstarter-configs package
# Rebuild db using target's rpm
echo -n "Rebuilding db using target rpm.."
rm -f /var/lib/rpm/__db*
rpm --rebuilddb
echo "done"
## end rpm-rebuilddb.post

## arch-armv7hl.post from mer-kickstarter-configs package
# Without this line the rpm don't get the architecture right.
echo -n 'armv7hl-meego-linux' &gt; /etc/rpm/platform

# Also libzypp has problems in autodetecting the architecture so we force tha as well.
# https://bugs.meego.com/show_bug.cgi?id=11484
echo 'arch = armv7hl' &gt;&gt; /etc/zypp/zypp.conf
## end arch-armv7hl.post

%end
</pre>
<p>Then create a target:</p>
<pre class="literal-block">
MerSDK$ sudo mic create fs mer-target-armv7hl.ks -o /parentroot/srv/mer/targets --pkgmgr=zypp --arch=armv7hl --tokenmap=MER_RELEASE:latest
MerSDK$ sudo chown -R $USER /parentroot/srv/mer/targets/mer-target-armv7hl/
</pre>
<p>Now tweak the target to recognize you:</p>
<pre class="literal-block">
MerSDK$ cd /parentroot/srv/mer/targets/mer-target-armv7hl/
MerSDK$ grep :$(id -u): /etc/passwd &gt;&gt; etc/passwd
MerSDK$ grep :$(id -g): /etc/group &gt;&gt; etc/group
</pre>
<p>Configure it to work with Scratchbox2 together:</p>
<pre class="literal-block">
MerSDK$ cd /parentroot/srv/mer/targets/mer-target-armv7hl/
MerSDK$ sb2-init -d -L "--sysroot=/" -C "--sysroot=/" -c /usr/bin/qemu-arm-dynamic -m sdk-build -n -N -t / mer-target-armv7hl /opt/cross/bin/armv7hl-meego-linux-gnueabi-gcc
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-install -R zypper ref --force
</pre>
<p>Clone web engine git repos to your local file system (e.g. into
the local directory <cite>/home/rozhkov/tmp/mozilla-temp/</cite>):</p>
<pre class="literal-block">
$ mkdir -p /home/rozhkov/tmp/mozilla-temp
$ cd /home/rozhkov/tmp/mozilla-temp
$ git clone git@github.com:tmeshkova/xulrunner-package.git
$ cd xulrunner-package
$ ./pull.all.sh
</pre>
<p>After that install build requirements to the rootfs:</p>
<pre class="literal-block">
MerSDK$ cd /home/rozhkov/tmp/mozilla-temp/xulrunner-package
MerSDK$ grep --color=never BuildRequires mozilla-central/rpm/xulrunner-qt5.spec | sed -e '/^#.*$/d' | gawk -F: '{ print $2 }' | tr ',' ' '| xargs sb2 -t mer-target-armv7hl -m sdk-install -R zypper in
MerSDK$ grep --color=never BuildRequires qtmozembed/rpm/qtmozembed-qt5.spec | sed -e '/^#.*$/d' | gawk -F: '{ print $2 }' | tr ',' ' '|xargs sb2 -t mer-target-armv7hl -m sdk-install -R zypper in
MerSDK$ grep --color=never BuildRequires embedlite-components/rpm/embedlite-components-qt5.spec | sed -e '/^#.*$/d' | gawk -F: '{ print $2 }' | tr ',' ' '|xargs sb2 -t mer-target-armv7hl -m sdk-install -R zypper in
MerSDK$ grep --color=never BuildRequires sailfish-browser/rpm/sailfish-browser.spec | sed -e '/^#.*$/d' | gawk -F: '{ print $2 }' | tr ',' ' '|xargs sb2 -t mer-target-armv7hl -m sdk-install -R zypper in
</pre>
<p>Remove the packages that are not really needed for engine development:</p>
<pre class="literal-block">
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-install -R zypper rm qtmozembed-qt5 qtmozembed-qt5-devel xulrunner-qt5 xulrunner-qt5-devel
</pre>
<p>And finally build the stuff with the <cite>build.sh</cite> script:</p>
<pre class="literal-block">
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-build ./build.sh -j -t mer
</pre>
<p>The option <cite>-j</cite> here makes <cite>build.sh</cite> build sailfish-browser binaries as well.</p>
<p>When everything is successfully built the script will show instructions on how
to run the newly built browser:</p>
<pre class="literal-block">
...
make[1]: Leaving directory `/home/rozhkov/tmp/mozilla-temp/xulrunner-package/sailfish-browser/src'
make: Leaving directory `/home/rozhkov/tmp/mozilla-temp/xulrunner-package/sailfish-browser'

prepare run-time environment:
export LD_LIBRARY_PATH=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer/src
export QML_IMPORT_PATH=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer/qmlplugin5
export QML2_IMPORT_PATH=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer/qmlplugin5

run unit-tests:
export QTTESTSROOT=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/tests
export QTTESTSLOCATION=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/tests/auto/mer-qt5
export QTMOZEMBEDOBJDIR=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer
/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/tests/auto/run-tests.sh

run test example:
/home/rozhkov/tmp/mozilla-temp/xulrunner-package/objdir-mer/dist/bin/qmlMozEmbedTestQt5  -fullscreen  -url about:license
/home/rozhkov/tmp/mozilla-temp/xulrunner-package/objdir-mer/dist/bin/sailfish-browser about:license
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p>Due to a bug in gecko build scripts you might encounter an error message about missing <cite>config.status</cite>
file after the build configuration phase. In this case just copy the file <cite>objdir-mer/config.status</cite>
to your working directory and run <cite>build.sh</cite> again:</p>
<pre class="last literal-block">
MerSDK$ cp objdir-mer/config.status .
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-build ./build.sh -j -t mer
</pre>
</div>
<p>The best way to test the build is to mount the working directory into the
device's file system so that the path to the built binaries on the device is
the same as in the host filesystem. For this you'll need to have the package
<cite>sshfs</cite> installed on the device:</p>
<pre class="literal-block">
[nemo@localhost-001 ~]$ mkdir tmp
[nemo@localhost-001 ~]$ sshfs rozhkov@192.168.2.14:/home/rozhkov/tmp tmp
[nemo@localhost-001 ~]$ devel-su
[root@localhost-001 nemo]$ cd /home
[root@localhost-001 home]$ ln -s nemo rozhkov
[root@localhost-001 home]$ exit
[nemo@localhost-001 ~]$ cd tmp/mozilla-temp/xulrunner-package
[nemo@localhost-001 xulrunner-package]$ export LD_LIBRARY_PATH=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer/src
[nemo@localhost-001 xulrunner-package]$ export QML_IMPORT_PATH=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer/qmlplugin5
[nemo@localhost-001 xulrunner-package]$ export QML2_IMPORT_PATH=/home/rozhkov/tmp/mozilla-temp/xulrunner-package/qtmozembed/objdir-mer/qmlplugin5
[nemo@localhost-001 xulrunner-package]$ /home/rozhkov/tmp/mozilla-temp/xulrunner-package/objdir-mer/dist/bin/sailfish-browser about:license
</pre>
<p>By now you should have working development environment. If you change code under
<cite>mozilla-central/embedding/embedlite</cite>, <cite>qtmozembed</cite>, <cite>embedlite-components</cite> or
<cite>sailfish-browser</cite> just run the <cite>build.sh</cite> script again:</p>
<pre class="literal-block">
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-build ./build.sh -j -t mer
</pre>
<p>If you change something inside other gecko components, e.g. under <cite>mozilla-central/dom/events</cite>
or <cite>mozilla-central/gfx</cite>,
then you'll need to rebuild the outdated object files too with the option <cite>-o</cite>:</p>
<pre class="literal-block">
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-build ./build.sh -j -t mer -o dom/events,gfx
</pre>
<p>This way there is no need to rebuild all other object files. And if you're working
on the engine only then you might want to use the option <cite>-e</cite> of <cite>build.sh</cite> that
makes the script to rebuild only the engine:</p>
<pre class="literal-block">
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-build ./build.sh -e -t mer
</pre>
<div class="section" id="useful-info">
<h3>Useful info</h3>
<p>If you're working on JS components don't forget to reset the start up cache
before testing your work:</p>
<pre class="literal-block">
[nemo@localhost-001 xulrunner-package]$ rm -fr ~/.mozilla/mozembed/startupCache/
</pre>
<p>If you need to switch on <a class="reference external" href="https://wiki.mozilla.org/MailNews:Logging">logging</a>
in the engine then define <cite>NSPR_LOG_MODULES</cite> environment variable:</p>
<pre class="literal-block">
[nemo@localhost-001 xulrunner-package]$ export NSPR_LOG_MODULES=TabChildHelper:5,EmbedLiteTrace:5,EmbedContentController:5
</pre>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">In order to see logging from components other than EmbedLite you'd need to
have a so called debug build of xulrunner. Use the option <cite>-d</cite> of the
<cite>build.sh</cite> script to create it.</p>
</div>
<p>Unfortunately the gecko build system is based on python which runs under qemu
inside Scratchbox2 by default (unless you do x86 build). It is possible to accelerate python though.
To achieve this you need to use a special Scratchbox2 mode <cite>sdk-build+pp</cite> and
to add the option <cite>-r</cite> to <cite>build.sh</cite>:</p>
<pre class="literal-block">
MerSDK$ sb2 -t mer-target-armv7hl -m sdk-build+pp ./build.sh -r -j -t mer
</pre>
<p>Happy hacking!</p>
</div>
</div></div>
        </div>
            
        
    <p>
        <a href="posts/how-to-configure-devel-environment-to-work-on-gecko-for-sailfishos.html#disqus_thread" data-disqus-identifier="cache/posts/how-to-configure-devel-environment-to-work-on-gecko-for-sailfishos.html">Comments</a>


        </p></article><article class="postbox h-entry post-text"><h1 class="p-name"><a href="posts/embedlite-initialization.html" class="u-url">EmbedLite Initialization</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2014-03-02T15:08:04+00:00">2014-03-02 15:08</time></small></h1>
        <hr><div class="e-content">
        <div><p>I guess some people may find useful the couple of words below on how
EmbedLite embedding is initialized. I've written them mostly because I'm trying
to wrap my head around the topic myself. So please let me know if you see non-sense.</p>
<div class="section" id="initialization-procedure">
<h2>Initialization procedure</h2>
<p>First of all a toolkit specific embedding (e.g. qtmozembed) must pre-configure
embedlite with the function <cite>LoadEmbedLite()</cite>. Then we should instantiate
<cite>EmbedLiteApp</cite> class. This is done with the function <cite>XRE_GetEmbedLite()</cite>.
Only one instance of <cite>EmbedLiteApp</cite> class can be created. Let's call this
singleton "embedLiteApp".</p>
<p>Next step is to set up callbacks to the embedding into "embedLiteApp". Currently
the callbacks should be implemented as a class inheriting to
<cite>EmbedLiteAppListener</cite>. The callbacks are called by "embedLiteApp" in order
either to notify our embedding about application-wide events or to configure
native threads. Only one instance of this callback collection makes sense.</p>
<p>Then the embedding (qtmozembed) should register all needed manifests of XPCOM
components with <cite>EmbedLiteApp::AddComponentManifest()</cite>.</p>
<p>At this stage a separate thread with embedlite can be started with either
<cite>EmbedLiteApp::StartWithCustomPump()</cite> or <cite>EmbedLiteApp::Start()</cite> methods.
The former method does an asynchronous call and returns immediately, the latter
one returns only after embedlite has stopped. After that the web engine starts
its initialization procedures.</p>
<p>Internally "embedLiteApp" schedules a call to its <cite>EmbedLiteApp::StartChild()</cite>
which is supposed to create a thread for embedlite either itself or with help
of a toolkit specific embedding (through the
<cite>EmbedLiteAppListener::ExecuteChildThread()</cite> callback) and inside the thread
it calls <cite>EmbedLiteApp::StartChildThread()</cite>. This function
loads manifests of XPCOM components, loads libxul.so, initializes the gecko
webengine, creates a new message loop for the thread and schedules creation of
"App Thread" actors or communication end points in other words. One end point
(an instance of <cite>EmbeLiteAppThreadParent</cite>) is a parent actor used to deliver
messages from the just created thread to the parent thread where "embedLiteApp"
lives. The other end point (an instance of <cite>EmbedLiteAppThreadChild</cite>) is a
child actor used to communicate with objects living in the child thread. At the
moment of creation the <cite>EmbedLiteAppThreadChild</cite> instance opens a communication
channel to <cite>EmbedLiteAppThreadParent</cite>. The communication protocol is defined
in the file <cite>PEmbedLiteApp.ipdl</cite>. Direct method calls from one thread to another
must be avoided since the objects can be placed into different processes actually,
not threads.</p>
<p>Basically the instance of <cite>EmbedLiteApp</cite> represents a chrome (or main UI) thread.
It communicates with a toolkit specific embedding through installed callbacks
(see <cite>EmbedLiteAppListner</cite>) and with Gecko webengine through the actor
<cite>EmbedLiteAppThreadParent</cite>.</p>
<p>Also the initialization procedures includes creation of <cite>EmbedLiteAppService</cite>
implementing the interface <cite>nsIEmbedAppService</cite>. This service keeps track of
created web views and is used by XPCOM components to communicate with the veiws.</p>
<p>After the implementation of <cite>nsIEmbedAppService</cite> is up and running the web
engine is considered to be fully functional. This event gets propagated to
the main UI thread (the parent actor receives the <cite>async Initialized()</cite>
message). Also the "embedliteInitialized" message is broadcasted with
<cite>nsIObserverService</cite>. From now on we can create actual web views.</p>
</div>
<div class="section" id="webview-creation">
<h2>WebView creation</h2>
<p>For every native widget representing a web view there should exist a corresponding
instance of <cite>EmbedLiteView</cite> class. This class exposes public API for web views
to the toolkit specific embedding (i.e. qtmozembed). Just like in the case of
<cite>EmbedLiteApp</cite> the embedding is supposed to register its callbacks to the
instance of <cite>EmbedLiteView</cite>. The callbacks are organized as virtual methods
of a class inheriting to <cite>EmbedLiteViewListener</cite>. A native widget is supposed
to instantiate the class and to register it with <cite>EmbedLiteView::SetListener()</cite>.</p>
<p>The instance of <cite>EmbedLiteView</cite> can be created by a native widget with the
method <cite>EmbedLiteApp::CreateView()</cite>. Internally in the method "embedliteApp"
generates an unique ID, then instantiates <cite>EmbedLiteView</cite> identified by the ID
and puts it into a local hash of views. After that it sends a message
<cite>async CreateView(viewId, parentViewId)</cite> to the gecko thread/process and returns
the just created <cite>EmbedLiteView</cite> instance to the native widget. The native
widget installs its callbacks and that's it. At this moment the <cite>EmbedLiteView</cite>
instance still cannot be used to communicate with the actual web view because it
doesn't exist yet.</p>
<p>When the gecko thread receives the message <cite>async CreateView()</cite> (via
<cite>EmbedLiteAppThreadChild::RecvCreateView()</cite>) it creates a pair of subprotocol
actors <cite>EmbedLiteViewThreadParent</cite> and <cite>EmbedLiteViewThreadChild</cite>. The former
lives in the same thread as <cite>EmbedLiteAppThreadParent</cite> does (the main UI
thread). And the latter lives in the gecko thread together with
<cite>EmbedLiteAppThreadChild</cite>. The parent end point for the view serves as
a communication channel to the corresponding web view which gets actually
created by the child end point. The act of web view creation happens in the
method <cite>EmbedLiteViewThreadChild::InitGeckoWindow()</cite>. Instances of
<cite>EmbedLiteViewThreadChild</cite> keep handles to the created "browser windows".
When a new "browser window" is created and properly initialized the child
end point sends a <cite>async Initialized()</cite> message to the corresponding parent.
The parent end point directly calls the callback <cite>ViewInitialized()</cite> registered
by the toolkit specific embedding. Now the native widget is notified that
its web view is fully functional.</p>
</div>
<div class="section" id="web-view-initialization">
<h2>Web view initialization</h2>
<p>So, what actually happens inside <cite>EmbedLIteViewThreadChild::InitGeckoWindow()</cite>?
First of all we create an object representing web browser, that is the object must
implemenent the interface <cite>nsIWebBrowser</cite>. The reference to this object is kept
in the private member <cite>EmbedLiteViewThreadChild::mWebBrowser</cite>.</p>
<p>Then we create an interface instance for the <cite>nsIBaseWindow</cite> interface out of the
web browser object.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Remember that interface instances of different types can refer to the same physical
object implementing more than one interfaces.</p>
</div>
<p>Also we create a fake browser widget <cite>EmbedLitePuppetWidget</cite> inheriting to
<cite>PuppetWidget</cite> and implementing the interface <cite>nsIWidget</cite>. This is how this
abstraction is described in Gecko code:</p>
<pre class="literal-block">
This "puppet widget" isn't really a platform widget.  It's intended
to be used in widgetless rendering contexts, such as sandboxed
content processes.  If any "real" widgetry is needed, the request
is forwarded to and/or data received from elsewhere.
</pre>
<p>Then we initialize the base window with the widget:</p>
<pre class="literal-block">
rv = baseWindow-&gt;InitWindow(0, mWidget, 0, 0, mViewSize.width, mViewSize.height);
if (NS_FAILED(rv)) {
  return;
}
</pre>
<p>The important part is that we initialize the window which hasn't been created
yet, because as said in the documentation for the property
<cite>nsIWebBrowser.containerWindow</cite>:</p>
<pre class="literal-block">
The embedder must create one chrome object for each browser object that is
instantiated. The embedder must associate the two by setting this property
to point to the chrome object before creating the browser window via the
browser's nsIBaseWindow interface.
</pre>
<p>After that we</p>
<blockquote>
<ol class="arabic simple"><li>create and initialize a chrome object (<cite>nsIWebBrowserChrome</cite>),</li>
<li>associate it with the web browser object,</li>
<li>finally create the base window (<cite>nsIBaseWindow</cite>),</li>
<li>request an interface object for <cite>nsIDOMWindow</cite> from the web browser object,</li>
<li>register the view ID in <cite>nsIEmbedAppService</cite>,</li>
<li>broadcast the event "embedliteviewcreated" on behalf of the <cite>nsIDOMWindow</cite>
instance to interested observers,</li>
<li>instantiate an interface object for <cite>nsIWebNavigation</cite> out of the base
window,</li>
<li>associate the web browser with the chrome object (so now they know each
other),</li>
<li>mark the base window visible,</li>
<li>create a <cite>TabChildHelper</cite> instance,</li>
<li>send <cite>async Initialized()</cite> message to the main UI thread.</li>
</ol></blockquote>
<p><cite>TabChildHelper</cite> is a private object handling various tasks for <cite>EmbedLiteViewThreadChild</cite>
such as viewport calculations and handling scroll events originating from
content.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The current goal is to make TabChildHelper share functionality with upstream dom/ipc/TabChild
class, in order to reduce maintenance burden.</p>
</div>
</div>
<div class="section" id="on-compositing">
<h2>On compositing</h2>
<p>The code of <cite>EmbedLitePuppetWidget</cite> basically is a copy-paste from mozilla's
<cite>PuppetWidget</cite> class. Would be nice to refactor it to avoid code duplication.
Mainly the code differs in how compositor objects are created. In fact the base
class <cite>PuppetWidget</cite> doesn't create any compositor objects since it's a
responsibility of a native widget, but embedlite does create a compositor
inside this fake widget by calling the static method
<cite>gfxPlatform::GetPlatform()</cite> (see <cite>EmbedLitePuppetWidget::CreateCompositor</cite>).
This method</p>
<blockquote>
<ol class="arabic"><li><p class="first">initializes a font rasterizer library,</p>
</li>
<li><p class="first">initializes Qt's graphic platform (looks like there is no much Qt specific
stuff left there),</p>
</li>
<li><p class="first">creates a Cairo surface,</p>
</li>
<li><p class="first">creates the compositor thread and the global compositor map if they haven't
been created before (see <cite>static void CompositorParent::StartUp()</cite>).</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Only one compositor thread per gecko proccess is created.</p>
</div>
</li>
<li><p class="first">creates the image bridge thread connected to the compositor thread via
the pair of actors <cite>ImageBridgeParent</cite> and <cite>ImageBridgeChild</cite>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The <cite>PImageBridge</cite> protocol is used to allow isolated threads or processes
to push frames directly to the compositor thread/process (from the content
thread) without relying on the main thread which might be too busy dealing
with content script. Again only one image bridge thread per gecko process
can be created.</p>
</div>
</li>
</ol></blockquote>
<p>In addition to that the fake widget creates</p>
<blockquote>
<ol class="arabic simple"><li>an instance of <cite>LayerManager</cite> class;</li>
<li>an instance of <cite>EmbedLiteCompositorParent</cite> class which is a subclass of the
<cite>CompositorParent</cite> actor class and a <cite>CompositorChild</cite> end point. This
<cite>CompositorChild</cite> instance serves as a communication channel to the
compositor thread for the <cite>LayerManager</cite> object;</li>
<li>a shadow manager (a child end point of the <cite>LayerTransaction</cite> subprotocol);</li>
<li>a shadow forwarder connected to the shadow manager</li>
</ol></blockquote>
<p>and registers the shadow manager in the image bridge. Images drawn in the content
thread by the layer manager get forwarded through the image bridge to the
compositor thread which is supposed to render the images into a GL context.
See <a class="reference external" href="https://wiki.mozilla.org/Gecko:Overview#Graphics">this page</a> for a better
explanation of compositing.</p>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently the <cite>EmbedLiteCompositorParent</cite> class implements methods that are
called from the main UI thread. But the object is supposed to live in the
compositor thread. This may become a problem if UI and gecko get moved to
separate processes.</p>
</div>
</div></div>
        </div>
            
        
    <p>
        <a href="posts/embedlite-initialization.html#disqus_thread" data-disqus-identifier="cache/posts/embedlite-initialization.html">Comments</a>


        </p></article><article class="postbox h-entry post-text"><h1 class="p-name"><a href="posts/whats-behind-sailfish-browser.html" class="u-url">What's behind Sailfish browser</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2014-02-09T14:07:14+00:00">2014-02-09 14:07</time></small></h1>
        <hr><div class="e-content">
        <div><p>In this post I'd like to shade some light on what technology is used in
the browser application for Sailfish OS.</p>
<p>By now it's a widely known fact that the browser is based on the Gecko engine
which is developed by Mozilla corp. and is used in their Firefox browser and
Firefox OS. For some reason it's not that known that the Sailfish browser is
built upon the <a class="reference external" href="https://github.com/tmeshkova/gecko-dev/tree/embedlite/embedding/embedlite">EmbedLite</a> embedding API (also known as IPCLiteAPI) for Gecko.</p>
<p>This embedding API started as a research project in Nokia by Oleg Romashin and
Andrey Petrov at the times when Nokia was still developing the Maemo platform.
Currently the project is maintained by Tatiana Meshkova.</p>
<p>It would help us a lot if the API made its way to the main Gecko repository and
became a part of the engine. Unfortunately this hasn't happened yet and the
current status of such integration you can see in these two bugs:</p>
<ol class="arabic simple"><li><a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=746800">https://bugzilla.mozilla.org/show_bug.cgi?id=746800</a></li>
<li><a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=713681">https://bugzilla.mozilla.org/show_bug.cgi?id=713681</a></li>
</ol><p>Later on Oleg has implemented a Qt embedding library (<a class="reference external" href="https://github.com/tmeshkova/qtmozembed">qtmozembed</a>) that uses this API. And this library
has enabled the development of a very
<a class="reference external" href="https://github.com/tmeshkova/qmlmozbrowser">lightweight Qt-based alternative to the Fennec browser</a>
for the Nokia N9 mobile phone. Also this browser has been ported to the Nemo project and
packaged as <a class="reference external" href="https://build.merproject.org/package/show?package=cutefox-qt5&amp;project=nemo%3Adevel%3Aapps">Cutefox</a>. Thanks to Andrey Kozhevnikov (aka CODERus), Stephan Beyerle (aka Morpog),
Michael Demetriou (aka qwazix) and Ivaylo Dimitrov (aka freemangordon).
The Cutefox browser became a starting point for the Sailfish browser.</p>
<p>Now let's see how all these components work together.</p>
<p>This <a class="reference external" href="https://wiki.mozilla.org/Embedding/IPCLiteAPI">page</a>
breifly describes the architecture of EmbedLite API. The key points are:</p>
<ul class="simple"><li>Native UI and Gecko engine live in different threads. Theoretically they can
live in different processes thanks to Mozilla's <a class="reference external" href="https://developer.mozilla.org/en-US/docs/IPDL/Tutorial">IPDL</a>.</li>
<li>Rendering is based on
<a class="reference external" href="https://wiki.mozilla.org/Platform/GFX/OffMainThreadCompositing#Design">off main thread compositing</a>
which provides multi-threaded responsive rendering. The same as in Firefox OS
and Firefox for Android.</li>
<li>XUL is not used.</li>
</ul><p>Basically EmbedLite provides API to:</p>
<ul class="simple"><li>start/terminate the Gecko engine in a separate thread/process;</li>
<li>create/destroy a web view;</li>
<li>install a toolkit specific listeners to receive events generated inside Gecko
in the native UI;</li>
<li>send messages/events from the native UI to Gecko;</li>
<li>get/set Gecko preferences;</li>
<li>load XPCOM components needed for features implemented in the native UI.</li>
</ul><p>This functionality is exposed with two main classes: <cite>EmbedLiteApp</cite> and <cite>EmbedLiteView</cite>.
<cite>EmbedLiteApp</cite> represents the Gecko engine. Only one instance of this class is allowed
to be created. <cite>EmbedLiteView</cite> represents a web view naturally. It's possible to create
many instances of this class.</p>
<p>Also EmbedLite defines two interfaces for toolkit specific
listeners: <cite>EmbedLiteAppListener</cite> and <cite>EmbedLiteViewListener</cite>. An implementor of a
toolkit specific embedding is supposed to implement listeners inhereting to those
interfaces. Particularly the Qt embedding I mentioned above implements these two
listeners in the classes <cite>QMozContextPrivate</cite> (derived from <cite>EmbedLiteAppListener</cite>)
and <cite>QGraphicsMozViewprivate</cite> (derived from <cite>EmbedLiteViewListener</cite>).</p>
<p>The Sailfish browser doesn't know anything about all these details. They are hidden
inside qtmozbed's interface classes:</p>
<ol class="arabic simple"><li><cite>QMozContext</cite> which encapsulates the web engine (via <cite>QMozContextPrivate</cite>);</li>
<li><cite>QuickMozView</cite> which encapsulets a web view (via <cite>QGraphicsMozViewPrivate</cite>) and
provides declarative QtQuick interface. In other words it can be used as a QML
component in your Qt application.</li>
</ol><p>Here's a bit outdated static model:</p>
<a class="reference external image-reference" href="images/qtembed.png"><img alt="/images/qtembed.png" src="images/qtembed.png"></a>
<p>In the next post I'll describe in more details what happens when EmbedLite is initialized
and a web view gets created.</p></div>
        </div>
            
        
    <p>
        <a href="posts/whats-behind-sailfish-browser.html#disqus_thread" data-disqus-identifier="cache/posts/whats-behind-sailfish-browser.html">Comments</a>


        </p></article><script>var disqus_shortname="idempotent";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script></div>
        <!--End of body content-->

        <footer>
            Contents © 2014         <a href="mailto:rozhkov@idempotent.com">Dmitry Rozhkov</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
        </footer></div>
</div>


            <script src="assets/js/all-nocdn.js" type="text/javascript"></script><script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script></body></html>