<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="author" content="Dmitry Rozhkov"><title>EmbedLite Initialization | Idempotent info</title><link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css"><link rel="canonical" href="http://idempotent.info/posts/embedlite-initialization.html"><!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]--><link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml"></head><body>
<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://idempotent.info/">Idempotent info</a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
        <ul class="nav navbar-nav"><li><a href="../stories/about.html">About</a>
                </li><li><a href="../archive.html">Archives</a>
                </li><li><a href="../categories/index.html">Tags</a>
                </li><li><a href="../rss.xml">RSS</a>

        </li></ul><ul class="nav navbar-nav navbar-right"><li>
    <a href="embedlite-initialization.rst" id="sourcelink">Source</a>
    </li>

        </ul></div><!-- /.navbar-collapse -->
</nav><!-- End of Menubar --><div class="container">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
    <article class="postbox post-text"><div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <h1 class="p-name" itemprop="headline name">EmbedLite Initialization</h1>

    <hr><small>
        Posted: <time class="published dt-published" datetime="2014-03-02T15:08:04+00:00" itemprop="datePublished">2014-03-02 15:08</time>
        

        
          |  
        More posts about 
    <span itemprop="keywords">
        <a class="tag p-category" href="../categories/gecko.html"><span class="badge badge-info">gecko</span></a>
        <a class="tag p-category" href="../categories/firefox.html"><span class="badge badge-info">firefox</span></a>
        <a class="tag p-category" href="../categories/mozilla.html"><span class="badge badge-info">mozilla</span></a>
        <a class="tag p-category" href="../categories/embedlite.html"><span class="badge badge-info">embedlite</span></a>
    </span>


    </small>
    <hr><div class="e-content" itemprop="articleBody text">
    <div><p>I guess some people may find useful the couple of words below on how
EmbedLite embedding is initialized. I've written them mostly because I'm trying
to wrap my head around the topic myself. So please let me know if you see non-sense.</p>
<div class="section" id="initialization-procedure">
<h2>Initialization procedure</h2>
<p>First of all a toolkit specific embedding (e.g. qtmozembed) must pre-configure
embedlite with the function <cite>LoadEmbedLite()</cite>. Then we should instantiate
<cite>EmbedLiteApp</cite> class. This is done with the function <cite>XRE_GetEmbedLite()</cite>.
Only one instance of <cite>EmbedLiteApp</cite> class can be created. Let's call this
singleton "embedLiteApp".</p>
<p>Next step is to set up callbacks to the embedding into "embedLiteApp". Currently
the callbacks should be implemented as a class inheriting to
<cite>EmbedLiteAppListener</cite>. The callbacks are called by "embedLiteApp" in order
either to notify our embedding about application-wide events or to configure
native threads. Only one instance of this callback collection makes sense.</p>
<p>Then the embedding (qtmozembed) should register all needed manifests of XPCOM
components with <cite>EmbedLiteApp::AddComponentManifest()</cite>.</p>
<p>At this stage a separate thread with embedlite can be started with either
<cite>EmbedLiteApp::StartWithCustomPump()</cite> or <cite>EmbedLiteApp::Start()</cite> methods.
The former method does an asynchronous call and returns immediately, the latter
one returns only after embedlite has stopped. After that the web engine starts
its initialization procedures.</p>
<p>Internally "embedLiteApp" schedules a call to its <cite>EmbedLiteApp::StartChild()</cite>
which is supposed to create a thread for embedlite either itself or with help
of a toolkit specific embedding (through the
<cite>EmbedLiteAppListener::ExecuteChildThread()</cite> callback) and inside the thread
it calls <cite>EmbedLiteApp::StartChildThread()</cite>. This function
loads manifests of XPCOM components, loads libxul.so, initializes the gecko
webengine, creates a new message loop for the thread and schedules creation of
"App Thread" actors or communication end points in other words. One end point
(an instance of <cite>EmbeLiteAppThreadParent</cite>) is a parent actor used to deliver
messages from the just created thread to the parent thread where "embedLiteApp"
lives. The other end point (an instance of <cite>EmbedLiteAppThreadChild</cite>) is a
child actor used to communicate with objects living in the child thread. At the
moment of creation the <cite>EmbedLiteAppThreadChild</cite> instance opens a communication
channel to <cite>EmbedLiteAppThreadParent</cite>. The communication protocol is defined
in the file <cite>PEmbedLiteApp.ipdl</cite>. Direct method calls from one thread to another
must be avoided since the objects can be placed into different processes actually,
not threads.</p>
<p>Basically the instance of <cite>EmbedLiteApp</cite> represents a chrome (or main UI) thread.
It communicates with a toolkit specific embedding through installed callbacks
(see <cite>EmbedLiteAppListner</cite>) and with Gecko webengine through the actor
<cite>EmbedLiteAppThreadParent</cite>.</p>
<p>Also the initialization procedures includes creation of <cite>EmbedLiteAppService</cite>
implementing the interface <cite>nsIEmbedAppService</cite>. This service keeps track of
created web views and is used by XPCOM components to communicate with the veiws.</p>
<p>After the implementation of <cite>nsIEmbedAppService</cite> is up and running the web
engine is considered to be fully functional. This event gets propagated to
the main UI thread (the parent actor receives the <cite>async Initialized()</cite>
message). Also the "embedliteInitialized" message is broadcasted with
<cite>nsIObserverService</cite>. From now on we can create actual web views.</p>
</div>
<div class="section" id="webview-creation">
<h2>WebView creation</h2>
<p>For every native widget representing a web view there should exist a corresponding
instance of <cite>EmbedLiteView</cite> class. This class exposes public API for web views
to the toolkit specific embedding (i.e. qtmozembed). Just like in the case of
<cite>EmbedLiteApp</cite> the embedding is supposed to register its callbacks to the
instance of <cite>EmbedLiteView</cite>. The callbacks are organized as virtual methods
of a class inheriting to <cite>EmbedLiteViewListener</cite>. A native widget is supposed
to instantiate the class and to register it with <cite>EmbedLiteView::SetListener()</cite>.</p>
<p>The instance of <cite>EmbedLiteView</cite> can be created by a native widget with the
method <cite>EmbedLiteApp::CreateView()</cite>. Internally in the method "embedliteApp"
generates an unique ID, then instantiates <cite>EmbedLiteView</cite> identified by the ID
and puts it into a local hash of views. After that it sends a message
<cite>async CreateView(viewId, parentViewId)</cite> to the gecko thread/process and returns
the just created <cite>EmbedLiteView</cite> instance to the native widget. The native
widget installs its callbacks and that's it. At this moment the <cite>EmbedLiteView</cite>
instance still cannot be used to communicate with the actual web view because it
doesn't exist yet.</p>
<p>When the gecko thread receives the message <cite>async CreateView()</cite> (via
<cite>EmbedLiteAppThreadChild::RecvCreateView()</cite>) it creates a pair of subprotocol
actors <cite>EmbedLiteViewThreadParent</cite> and <cite>EmbedLiteViewThreadChild</cite>. The former
lives in the same thread as <cite>EmbedLiteAppThreadParent</cite> does (the main UI
thread). And the latter lives in the gecko thread together with
<cite>EmbedLiteAppThreadChild</cite>. The parent end point for the view serves as
a communication channel to the corresponding web view which gets actually
created by the child end point. The act of web view creation happens in the
method <cite>EmbedLiteViewThreadChild::InitGeckoWindow()</cite>. Instances of
<cite>EmbedLiteViewThreadChild</cite> keep handles to the created "browser windows".
When a new "browser window" is created and properly initialized the child
end point sends a <cite>async Initialized()</cite> message to the corresponding parent.
The parent end point directly calls the callback <cite>ViewInitialized()</cite> registered
by the toolkit specific embedding. Now the native widget is notified that
its web view is fully functional.</p>
</div>
<div class="section" id="web-view-initialization">
<h2>Web view initialization</h2>
<p>So, what actually happens inside <cite>EmbedLIteViewThreadChild::InitGeckoWindow()</cite>?
First of all we create an object representing web browser, that is the object must
implemenent the interface <cite>nsIWebBrowser</cite>. The reference to this object is kept
in the private member <cite>EmbedLiteViewThreadChild::mWebBrowser</cite>.</p>
<p>Then we create an interface instance for the <cite>nsIBaseWindow</cite> interface out of the
web browser object.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Remember that interface instances of different types can refer to the same physical
object implementing more than one interfaces.</p>
</div>
<p>Also we create a fake browser widget <cite>EmbedLitePuppetWidget</cite> inheriting to
<cite>PuppetWidget</cite> and implementing the interface <cite>nsIWidget</cite>. This is how this
abstraction is described in Gecko code:</p>
<pre class="literal-block">
This "puppet widget" isn't really a platform widget.  It's intended
to be used in widgetless rendering contexts, such as sandboxed
content processes.  If any "real" widgetry is needed, the request
is forwarded to and/or data received from elsewhere.
</pre>
<p>Then we initialize the base window with the widget:</p>
<pre class="literal-block">
rv = baseWindow-&gt;InitWindow(0, mWidget, 0, 0, mViewSize.width, mViewSize.height);
if (NS_FAILED(rv)) {
  return;
}
</pre>
<p>The important part is that we initialize the window which hasn't been created
yet, because as said in the documentation for the property
<cite>nsIWebBrowser.containerWindow</cite>:</p>
<pre class="literal-block">
The embedder must create one chrome object for each browser object that is
instantiated. The embedder must associate the two by setting this property
to point to the chrome object before creating the browser window via the
browser's nsIBaseWindow interface.
</pre>
<p>After that we</p>
<blockquote>
<ol class="arabic simple"><li>create and initialize a chrome object (<cite>nsIWebBrowserChrome</cite>),</li>
<li>associate it with the web browser object,</li>
<li>finally create the base window (<cite>nsIBaseWindow</cite>),</li>
<li>request an interface object for <cite>nsIDOMWindow</cite> from the web browser object,</li>
<li>register the view ID in <cite>nsIEmbedAppService</cite>,</li>
<li>broadcast the event "embedliteviewcreated" on behalf of the <cite>nsIDOMWindow</cite>
instance to interested observers,</li>
<li>instantiate an interface object for <cite>nsIWebNavigation</cite> out of the base
window,</li>
<li>associate the web browser with the chrome object (so now they know each
other),</li>
<li>mark the base window visible,</li>
<li>create a <cite>TabChildHelper</cite> instance,</li>
<li>send <cite>async Initialized()</cite> message to the main UI thread.</li>
</ol></blockquote>
<p><cite>TabChildHelper</cite> is a private object handling various tasks for <cite>EmbedLiteViewThreadChild</cite>
such as viewport calculations and handling scroll events originating from
content.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The current goal is to make TabChildHelper share functionality with upstream dom/ipc/TabChild
class, in order to reduce maintenance burden.</p>
</div>
</div>
<div class="section" id="on-compositing">
<h2>On compositing</h2>
<p>The code of <cite>EmbedLitePuppetWidget</cite> basically is a copy-paste from mozilla's
<cite>PuppetWidget</cite> class. Would be nice to refactor it to avoid code duplication.
Mainly the code differs in how compositor objects are created. In fact the base
class <cite>PuppetWidget</cite> doesn't create any compositor objects since it's a
responsibility of a native widget, but embedlite does create a compositor
inside this fake widget by calling the static method
<cite>gfxPlatform::GetPlatform()</cite> (see <cite>EmbedLitePuppetWidget::CreateCompositor</cite>).
This method</p>
<blockquote>
<ol class="arabic"><li><p class="first">initializes a font rasterizer library,</p>
</li>
<li><p class="first">initializes Qt's graphic platform (looks like there is no much Qt specific
stuff left there),</p>
</li>
<li><p class="first">creates a Cairo surface,</p>
</li>
<li><p class="first">creates the compositor thread and the global compositor map if they haven't
been created before (see <cite>static void CompositorParent::StartUp()</cite>).</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Only one compositor thread per gecko proccess is created.</p>
</div>
</li>
<li><p class="first">creates the image bridge thread connected to the compositor thread via
the pair of actors <cite>ImageBridgeParent</cite> and <cite>ImageBridgeChild</cite>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The <cite>PImageBridge</cite> protocol is used to allow isolated threads or processes
to push frames directly to the compositor thread/process (from the content
thread) without relying on the main thread which might be too busy dealing
with content script. Again only one image bridge thread per gecko process
can be created.</p>
</div>
</li>
</ol></blockquote>
<p>In addition to that the fake widget creates</p>
<blockquote>
<ol class="arabic simple"><li>an instance of <cite>LayerManager</cite> class;</li>
<li>an instance of <cite>EmbedLiteCompositorParent</cite> class which is a subclass of the
<cite>CompositorParent</cite> actor class and a <cite>CompositorChild</cite> end point. This
<cite>CompositorChild</cite> instance serves as a communication channel to the
compositor thread for the <cite>LayerManager</cite> object;</li>
<li>a shadow manager (a child end point of the <cite>LayerTransaction</cite> subprotocol);</li>
<li>a shadow forwarder connected to the shadow manager</li>
</ol></blockquote>
<p>and registers the shadow manager in the image bridge. Images drawn in the content
thread by the layer manager get forwarded through the image bridge to the
compositor thread which is supposed to render the images into a GL context.
See <a class="reference external" href="https://wiki.mozilla.org/Gecko:Overview#Graphics">this page</a> for a better
explanation of compositing.</p>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently the <cite>EmbedLiteCompositorParent</cite> class implements methods that are
called from the main UI thread. But the object is supposed to live in the
compositor thread. This may become a problem if UI and gecko get moved to
separate processes.</p>
</div>
</div></div>
    </div>
    </div>
    
        <ul class="pager"><li class="previous">
                <a href="whats-behind-sailfish-browser.html" rel="prev">← Previous post</a>
            </li>
        </ul><div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="idempotent",
            disqus_url="http://idempotent.info/posts/embedlite-initialization.html",
        disqus_title="EmbedLite Initialization",
        disqus_identifier="cache/posts/embedlite-initialization.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


    

    </article></div>
        <!--End of body content-->

        <footer>
            Contents © 2014         <a href="mailto:rozhkov@idempotent.com">Dmitry Rozhkov</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
        </footer></div>
</div>


            <script src="../assets/js/all-nocdn.js" type="text/javascript"></script><script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script></body></html>